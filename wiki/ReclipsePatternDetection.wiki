#summary Description of the pattern detection in Reclipse.

<wiki:toc max_depth="4" />

= Introduction =

In addition to this documentation, you should have a look at the _Reclipse Help Plug-In (org.reclipse.structure.help)_ that can be found in the Reclipse repository (http://dsd-serv.uni-padern.de/svn/reclipse-emf).

The pattern detection in Reclipse consists of three basic parts:

 # _Formalization_ of the patterns that are to be detection.
 # _Generation_ of detection engines (i.e. story diagrams) from the formalized patterns.
 # _Detection_ of the patterns by executing the generated engines.


= Pattern Formalization =

Structural patterns can be specified in a graphical DSL using a GEF editor. The patterns show object structures that represent a certain design pattern or design deficiency and that are to be detected in the host graph. 

http://archimetrix.googlecode.com/svn/wiki/images/PatternFormalizationEditor.png

The formalizations consist of the following major parts:

 * *Mandatory, core elements*: Normal objects and links which are displayed in black in the concrete syntax. The objects and links have to be found in the host graph for a pattern occurrence to be present. All constraints on mandatory objects have to hold (except for constraints that are explicitly marked as additional).
 * Negative elements: Negative objects and links are crossed out in the concrete syntax (e.g the _publicConstructor_ object in the screenshot above). If these elements are found, that means that no valid pattern occurrence exists at that point of the host graph.
 * Set fragments: In some cases, it is necessary to express that a pattern can contain more than one occurrence of a certain object (e.g. more than one concrete startegy in a strategy pattern). This can be achieved by enclosing the group of objects in a set fragment. If only one object should can exist more often than once, a short-hand notation for the set fragment is the (semantically equivalent) "set object" which is displayed with a stacked border. Note that sets may always be empty, i.e. they are realized with a 0..´* semantics.
 * Additonal elements: Sometimes,  
 * Sub patterns:
 * The annotation:

More examples and explanations about the DSL can be found here: 
 * [http://ubdok.uni-paderborn.de/servlets/DocumentServlet?id=5163 Ph.D. thesis by Jörg Niere (German)]
 * [http://ubdok.uni-paderborn.de/servlets/DocumentServlet?id=5625 Ph.D. thesis by Lothar Wendehals (German)]
 * [http://ubdok.uni-paderborn.de/servlets/DocumentServlet?id=11678 Ph.D. thesis by Matthias Meyer (German)]
 * Technical report: https://www.hni.uni-paderborn.de/publikationen/publikationen/?tx_hnippview_pi1[publikation]=6951


== Metamodel registration ==
The objects are typed over a EMF metamodel. In the case of Archimetrix, this metamodel is the combination of Source Code Decorator metamodel, SAM metamodel, and GAST metamodel. The registration of metamodels can be accomplished via the extension point _org.reclipse.structure.specification.metamodel_. The registration of the metamodels used in Archimetrix is performed in the plug-in _org.reclipse.gast_.



= Engine Generation = 

== Generation Process ==

The picture shows the general process for the generation of detection engines from the pattern formalizations.

http://archimetrix.googlecode.com/svn/wiki/images/EngineGenerationProcess.png

The engines are generated into an Ecore file which is typically named _"catalogName".psc.ecore_. This Ecore file contains two packages: 
 * One package for the annotations and 
 * one package for the engines.

For every pattern formalization, an annotation class is generated in the annotations package. Objects of these annotation classes are created during the pattern detection and attached to the pattern occurrences in the host graph.

In the engines package, an engine class is created for each to pattern formalization, provided it is not an abstract pattern. (Abstract patterns only define the roles that are played in a pattern but not how they are connected, i.e. they cannot be detected in the host graph but have to be extended by concrete patterns).

The engine class contains three methods:

 # _annotate_: This is the main method for the detection of a corresponding pattern. It tries to match the core structure of the pattern in the host graph and calls the other methods if necessary.
 # _findAdditionalElements_: This method is used to find additonal fragments of a pattern in the host graph.
 # _findSetFragments_:

== Generation of expressions ==

Originally, the story diagram meta model was devised with a complete sub package for the modeling of expressions. However, this was pretty complicated and noone ever created a working interpreter for that. Therefore, in the current version of the SD metamodel as described in the techreport v0.2 (https://www.hni.uni-paderborn.de/publikationen/publikationen/?tx_hnippview_pi1[publikation]=6886), OCL is used for the evaluation of expression.

The different constraints that can be modeled in Reclipse patterns (e.g. attribute constraints) are translated into OCL constraints by the class _org.reclipse.structure.generator.util.ExpressionsUtil_.

= Pattern Detection = 

http://archimetrix.googlecode.com/svn/wiki/images/PatternDetectionProcess.png